# LCGPredictor
This program can predict random numbers generated by a liner congruential generator (LCG) giving the formula it used. It can calculate:
* The inverse formula, which generate the last random number from the next one.
* What number will it generate after exactly N times of recursion.
* How many times of recursion are needed to generate a certain random number starting from 0.
## How is this done
First of all, this program only works when the LCG formula can generate all numbers from 0 to 2^n - 1. In this condition, this is how it works:  
### Part 1: Get the inverse formula(s)
Let's assume the orininal formula used by the LCG is `f[1](x) = a[1] * x + c[1]` (omitting the modulus part). This formula generates the next random number, so we say this formula "pushes" the random number once.  

Then, we have `f[1](f[1](x)) = a[1] * (a[1] * x + c[1]) + c[1] = a[1] * a[1] * x + a[1] * c[1] + c[1]`, this pushes the random number twice. Let `a[2] = a[1] * a[1]`, `c[2] = a[1] * c[1] + c[1]`, we get a formula: `f[2](x) = a[2] * x + c[2]`, which pushes the random number twice.  

We do this repeatedly and we will get `f[4]`, `f[8]`, `f[16]`, `f[32]`, ..., `f[2^(n-1)]`, which respectively pushes the random number 4 times, 8 times, 16 times, 32 times, ..., 2^(n-1) times. Push the random number 2^n times will just get the number itself so we don't do that.  

Now, if we calculate `f[2](f[1](x))`, we can get `f[3]`, which pushes the random number 3 times. So we have `f[3](x) = a[3] * x + c[3]`, where `a[3] = a[2] * a[1]`, `c[3] = a[2] * c[1] + c[2]`. It seems that `c[3]` can have 2 different expressions: `c[3] = a[2] * c[1] + c[2]` and `c[3] = a[1] * c[2] + c[1]`, but they are actually the same.  

With the same way, we can get `f[1 + 2 + 4]`, `f[1 + 2 + 4 + 8]`, until `f[1 + 2 + 4 + 8 + ... + 2^(n-1)]`. The last formula pushes the random number 2^n - 1 times, and it actually pushes -1 time, as pushing 2^n times is equal to doing nothing. This is how we get the inverse formula `f[-1]`.  

Then we can get `f[-2]`, `f[-4]`, `f[-8]`, ..., `f[-2^(n-1)]`.  
### Part 2: Get random number after N times of recursion
This is actually already shown is the last part. As we have `f[1]`, `f[2]`, `f[4]`, `f[8]` and so on, we can have any `f[n]` just by combining certain formulas. For example, if we need `f[100]`, we can do `f[100] = f[64 + 32 + 4]`.  
### Part 3: Get how many times of recursion are needed to generate a certain random number
This part is the trickiest part. We need to know 2 properties of the random number sequence generated by LCG (which is a "good" LCG that generates all numbers from 0 to 2^n - 1):  
* The n-th least significant bit of the numbers loops every 2^n numbers.
* For the N-th number and the (N + 2^(n-1))-th number, the n-th least significant bit of the number are always reversed. 
    - For example, if the third least significant bit of the 4th number is 1, the third least significant bit of the 8th number must be 0.

These 2 properties are NOT mathematically proved. They just always work so far, for all "good" LCGs.  

Knowing these 2 properties, this is how the program works:  

First we examine the least significant bit of the number. If it is 0, do nothing; if it is 1, we push the number -1 times using `f[-1]`. Due to the second property, the least significant bit is 0 now.  

Then we examine the second least significant bit. If it is 0, do nothing; if it is 1, we push the number -2 times using `f[-2]`. The second least significant bit is 0 now; and the least significant bit keeps to be 0, due to the first property.  

Then the third least significant bit, and so on. Finally, we will make every bit of the number to become 0, so the number becomes 0. We just need to add up how much times we have pushed the number back, and this is how many times of recursion are needed to get this number.  
#### Another solution in which even `f[-1]` is not needed
Instead of pushing number back, we can push number forward. For the least significant bit of the number, if it is 1, we push the number once using `f[1]`. for the second least significant bit, push the number twice using `f[2]` and so on. We still need to add up how much times we have pushed the number forward when we reach 0, and then we just use 2^n to substract it to get the actual times we needed.  
